<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[求星期问题]]></title>
    <url>%2F%E6%B1%82%E6%98%9F%E6%9C%9F%E9%97%AE%E9%A2%98-1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[stringstream用法]]></title>
    <url>%2Fstringstream%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[stringstream的用法没有接触过stringstream这个类的时候，常用的字符串和数字转换函数就是sscanf和sprintf函数。 c++中引入了流的概念，通过流来实现字符串和数字的转换方便多了。 1. string首先说一下string的用法,与传统的字符数组相比 加入头文件#include &lt;string&gt; 操作 string 字符数组 定义上 string s char s[100] 取得第 i 個字元 s[i] s[i] 字串長度 s.length()或 s.size() strlen(s) 读取一行 getline(cin, s) gets(s) 设成某字串 s=”TCGS”; strcpy(s, “TCGS”) 字串相加 s=s+”TCGS” strcat(s, “TCGS”); 字串比较 s==”TCGS” strcmp(s, “TCGS”) 除size()外，另外两个string常用的方法是find和substr。 在下面的代码当中： ​ string str = “aaaaddddssdfsasdf”; ​ size_t pos = str.find(“ssdf”, 3); //用if(pos == string::npos) 用来判断是否找到子串。 ​ string str2 = str.substr(pos, 5); ​ find函数从str的第3个位置查起，找到ssdf这个子串后，返回子串的位置。而substr函数从pos位置开始，截取5个字符，赋值给str2。也就是说，str2之后的内容将是ssdfs。 2. stringstreamstringstream 是 C++ 提供的另一个字串型的串流(stream)物件，和之前学过的 iostream、fstream 有类似的操作方式。要使用 stringstream， 必須先加入 #include &lt;sstream&gt; stringstream 主要是用在將一個字串分割，可以先用 clear( )以及 str( ) 將指定字串設定成一开始的內容，再用 &gt;&gt; 把个別的资料输出 1234567string s;stringstream ss;int a, b, c;getline(cin, s);ss.clear();ss.str(s);ss &gt;&gt; a &gt;&gt; b &gt;&gt; c; 123456789101112131415161718192021222324252627282930313233343536題目：输入的第一行有一个数字 N 代表接下來有 N 行資料，每一行資料里有不固定個數的整數(最多 20 個，每行最大 200 個字元)，請你寫一個程式將每行的总和印出來。輸入：31 2 320 17 23 54 77 60111 222 333 444 555 666 777 888 999輸出：62514995程式如下：string s;stringstream ss;int n, i, sum, a;cin &gt;&gt; n;getline(cin, s); // 讀取換行for (i=0; i&lt;n; i++)&#123; getline(cin, s); ss.clear(); ss.str(s); sum=0; while (1) &#123; ss &gt;&gt; a; if ( ss.fail() ) break; sum+=a; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125; 实例例子一：基本数据类型转换例子 int转string 12345678910111213#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;iostream&gt; int main()&#123; std::stringstream stream; std::string result; int i = 1000; stream &lt;&lt; i; //将int输入流 stream &gt;&gt; result; //从stream中抽取前面插入的int值 std::cout &lt;&lt; result &lt;&lt; std::endl; // print the string "1000"&#125; 例子二：除了基本类型的转换，也支持char *的转换。 1234567891011#include &lt;sstream&gt;#include &lt;iostream&gt; int main()&#123; std::stringstream stream; char result[8] ; stream &lt;&lt; 8888; //向stream中插入8888 stream &gt;&gt; result; //抽取stream中的值到result std::cout &lt;&lt; result &lt;&lt; std::endl; // 屏幕显示 "8888"&#125; 例子三：再进行多次转换的时候，必须调用stringstream的成员函数clear() 1234567891011121314#include &lt;sstream&gt;#include &lt;iostream&gt;int main()&#123; std::stringstream stream; int first, second; stream&lt;&lt; "456"; //插入字符串 stream &gt;&gt; first; //转换成int std::cout &lt;&lt; first &lt;&lt; std::endl; stream.clear(); //在进行多次转换前，必须清除stream stream &lt;&lt; true; //插入bool值 stream &gt;&gt; second; //提取出int std::cout &lt;&lt; second &lt;&lt; std::endl;&#125; 例子四 1234567891011121314#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std; int main()&#123; stringstream ss; char szTest[] = "abc"; ss &lt;&lt; "hello" &lt;&lt; 123 &lt;&lt; szTest; cout &lt;&lt; ss.str() &lt;&lt; endl; return 0;&#125; 总结：1）在istringstream类中，构造字符串流时，空格会成为字符串参数的内部分界； 2）istringstream类可以用作string与各种类型的转换途径 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include &lt;sstream&gt; using namespace std;&lt;pre name="code" class="cpp"&gt;int main()&#123; string test = "-123 9.87 welcome to, 989, test!"; istringstream iss;//istringstream提供读 string 的功能 iss.str(test);//将 string 类型的 test 复制给 iss，返回 void string s; cout &lt;&lt; "按照空格读取字符串:" &lt;&lt; endl; while (iss &gt;&gt; s)&#123; cout &lt;&lt; s &lt;&lt; endl;//按空格读取string &#125; cout &lt;&lt; "*********************" &lt;&lt; endl; istringstream strm(test); //创建存储 test 的副本的 stringstream 对象 int i; float f; char c; char buff[1024]; strm &gt;&gt; i; cout &lt;&lt;"读取int类型："&lt;&lt; i &lt;&lt; endl; strm &gt;&gt; f; cout &lt;&lt;"读取float类型："&lt;&lt;f &lt;&lt; endl; strm &gt;&gt; c; cout &lt;&lt;"读取char类型："&lt;&lt; c &lt;&lt; endl; strm &gt;&gt; buff; cout &lt;&lt;"读取buffer类型："&lt;&lt; buff &lt;&lt; endl; strm.ignore(100, ','); int j; strm &gt;&gt; j; cout &lt;&lt;"忽略‘，’读取int类型："&lt;&lt; j &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目准备工作]]></title>
    <url>%2Fvue%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建一个vue项目的准备工作 安装vue脚手架工具vue cli npm install -g @vue/cli-service-global ps: 注意检查Node和npm的版本 利用脚手架工具创建vue项目 vue create project_name 创建成功后根据提示,在本地运行项目 12$ cd miaomiao$ npm run serve 然后根据给定的端口进行访问 http://localhost:8080/ 使用git进行多人协同开发 首先在github上新建一个远程仓库,按照个人情况进行配置 12345git remote //查看远程仓库,初始远程仓库为空git remote add origin SSH地址(github上有) // 创建远程仓库git push origin master //把本地分支push到远程仓库 之后在github上即可看到本地代码成功上传了 因为多人开发可能会出现冲突,所以最好切换到一个新分支,同一由项目经理把开发分支合并到master分支 123git checkout -b devgit push origin dev]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mint UI 的使用]]></title>
    <url>%2Fmint-UI-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[mintUI介绍特性介绍 Mint UI 包含丰富的 CSS 和 JS 组件，能够满足日常的移动端开发需要。通过它，可以快速构建出风格统一的页面，提升开发效率。 真正意义上的按需加载组件。可以只加载声明过的组件及其样式文件，无需再纠结文件体积过大。 考虑到移动端的性能门槛，Mint UI 采用 CSS3 处理各种动效，避免浏览器进行不必要的重绘和重排，从而使用户获得流畅顺滑的体验。 依托 Vue.js 高效的组件化方案，Mint UI 做到了轻量化。即使全部引入，压缩后的文件体积也仅有 ~30kb (JS + CSS) gzip。 mintUI的使用 找官网 mintUI官网 安装i mint-ui -S```123456789101112131415163. 引入mintUI的CSS和插件 ```js // main.js import Vue from &apos;vue&apos; import MintUI from &apos;mint-ui&apos; import &apos;mint-ui/lib/style.css&apos; import App from &apos;./App.vue&apos; Vue.use(MintUI) new Vue(&#123; el: &apos;#app&apos;, components: &#123; App &#125; &#125;) 看文档直接使用(以上在main.js全局引入,不需要再调用组件的时候重复引用) element UI的的使用 找官网 elementUI官网 安装 i element-ui -S``` -S表示 --save123456789101112131415163. 引入element UI的CSS和插件 ```js // main.js import Vue from &apos;vue&apos;; import ElementUI from &apos;element-ui&apos;; import &apos;element-ui/lib/theme-chalk/index.css&apos;; import App from &apos;./App.vue&apos;; Vue.use(ElementUI); new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App) &#125;); 配置file_loader { ​ test:, ​ loader: ‘file_loader’ } 看文档使用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>UI</tag>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF2017-9月]]></title>
    <url>%2FCCF2017-9%E6%9C%88%2F</url>
    <content type="text"><![CDATA[CCF2017-9月1.打酱油问题描述 小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。 输入格式 输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。 输出格式 输出一个整数，表示小明最多可以得到多少瓶酱油。 样例输入 40 样例输出 5 样例说明 把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。 样例输入 80 样例输出 11 样例说明 把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。 参考代码: 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main() &#123; int num = 0,mon; cin&gt;&gt;mon; if(mon &lt; 30) num = mon / 10; //25 else if(mon &lt; 50) num = 4 + (mon - 30) / 10; // 45 else &#123; // 290 int temp,res; temp = mon / 50; // 5 res = mon % 50; // 40 num = temp*7; // 35 temp = res / 30; // 1 res = res % 30; // 10 num += 4*temp; // 39 num += res/10; // 40 &#125; cout&lt;&lt;num; return 0;&#125; 2. 公共钥匙盒问题描述 有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。 钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。 每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。 今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？ 输入格式 输入的第一行包含两个整数N, K。 接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。 保证输入数据满足输入格式，你不用检查数据合法性。 输出格式 输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。 样例输入 5 24 3 32 2 7 样例输出 1 4 3 2 5 样例说明 第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。 每个关键时刻后的钥匙状态如下（X表示空）： 时刻2后为1X345； 时刻3后为1X3X5； 时刻6后为143X5； 时刻9后为14325。 样例输入 5 71 1 143 3 121 15 122 7 203 18 124 21 195 30 9 样例输出 1 2 3 5 4 评测用例规模与约定 对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30； 对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50； 对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。 思路分析: ​ 这道题关键的问题是有效解决取钥匙和还钥匙的问题,二者不可以分开进行,必须合并成一个过程,这样才能保证正常的逻辑。 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct teacher&#123; int id; int time; int sign;&#125;;//进行排序bool cmp(teacher a,teacher b)&#123; if(a.time!=b.time) return a.time&lt;b.time; else &#123; if(a.sign!=b.sign) return a.sign&lt;b.sign; else return a.id&lt;b.id; &#125;&#125;int main()&#123; int n,k; struct teacher a[2005]; int b[1005]; cin&gt;&gt;n&gt;&gt;k; int w,s,c; //既要将取钥匙时间输入数组中，也要将还钥匙的时间输入数组中，所以会有i*2，i*2+1 for(int i=0;i&lt;k;i++)&#123; cin&gt;&gt;w&gt;&gt;s&gt;&gt;c; a[i*2].id=w; //取 a[i*2].time=s; a[i*2].sign=1; a[i*2+1].id=w; //还 a[i*2+1].time=s+c; a[i*2+1].sign=-1; &#125; sort(a,a+2*k,cmp); //先将按从小到大排好的n个数放入数组b中 for(int j=1;j&lt;=n;j++)&#123; b[j]=j; &#125; for(int i=0;i&lt;2*k;i++)&#123; //模拟取钥匙 if(a[i].sign==1)&#123; for(int j=1;j&lt;=n;j++)&#123; if(b[j]==a[i].id) b[j]=0; &#125; &#125; //模拟还钥匙 else&#123; for(int j=1;j&lt;=n;j++)&#123; if(b[j]==0)&#123; b[j]=a[i].id; break;&#125; //已经把钥匙还回去放到空位，要及时的break，否则所有的空位都会放上这个钥匙 &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i!=1) printf(" "); printf("%d",b[i]); &#125; printf("\n"); return 0;&#125; 3 .JSON查询问题描述 JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，可以用来描述半结构化的数据。JSON 格式中的基本单元是值 (value)，出于简化的目的本题只涉及 2 种类型的值： 字符串 (string)：字符串是由双引号 “ 括起来的一组字符（可以为空）。如果字符串的内容中出现双引号 “，在双引号前面加反斜杠，也就是用 &quot; 表示；如果出现反斜杠 \，则用两个反斜杠 \ 表示。反斜杠后面不能出现 “ 和 \ 以外的字符。例如：””、”hello”、”&quot;\“。 对象 (object)：对象是一组键值对的无序集合（可以为空）。键值对表示对象的属性，键是属性名，值是属性的内容。对象以左花括号 { 开始，右花括号 } 结束，键值对之间以逗号 , 分隔。一个键值对的键和值之间以冒号 : 分隔。键必须是字符串，同一个对象所有键值对的键必须两两都不相同；值可以是字符串，也可以是另一个对象。例如：{}、{“foo”: “bar”}、{“Mon”: “weekday”, “Tue”: “weekday”, “Sun”: “weekend”}。 除了字符串内部的位置，其他位置都可以插入一个或多个空格使得 JSON 的呈现更加美观，也可以在一些地方换行，不会影响所表示的数据内容。例如，上面举例的最后一个 JSON 数据也可以写成如下形式。 { “Mon”: “weekday”, “Tue”: “weekday”, “Sun”: “weekend” } 给出一个 JSON 格式描述的数据，以及若干查询，编程返回这些查询的结果。 输入格式 第一行是两个正整数 n 和 m，分别表示 JSON 数据的行数和查询的个数。 接下来 n 行，描述一个 JSON 数据，保证输入是一个合法的 JSON 对象。 接下来 m 行，每行描述一个查询。给出要查询的属性名，要求返回对应属性的内容。需要支持多层查询，各层的属性名之间用小数点 . 连接。保证查询的格式都是合法的。 输出格式 对于输入的每一个查询，按顺序输出查询结果，每个结果占一行。 如果查询结果是一个字符串，则输出 STRING ，其中 是字符串的值，中间用一个空格分隔。 如果查询结果是一个对象，则输出 OBJECT，不需要输出对象的内容。 如果查询结果不存在，则输出 NOTEXIST。 样例输入 10 5{“firstName”: “John”,“lastName”: “Smith”,“address”: {“streetAddress”: “2ndStreet”,“city”: “NewYork”,“state”: “NY”},“esc\aped”: “&quot;hello&quot;“}firstNameaddressaddress.cityaddress.postalesc\aped 样例输出 STRING JohnOBJECTSTRING NewYorkNOTEXISTSTRING “hello” 评测用例规模与约定 n ≤ 100，每行不超过 80 个字符。 m ≤ 100，每个查询的长度不超过 80 个字符。 字符串中的字符均为 ASCII 码 33-126 的可打印字符，不会出现空格。所有字符串都不是空串。 所有作为键的字符串不会包含小数点 .。查询时键的大小写敏感。 50%的评测用例输入的对象只有 1 层结构，80%的评测用例输入的对象结构层数不超过 2 层。举例来说，{“a”: “b”} 是一层结构的对象，{“a”: {“b”: “c”}} 是二层结构的对象，以此类推。 解题思路: ​ 首先很容易想到使用map映射,用来存储键和键值的对应关系,通过对JSON字符串的遍历 1. 当遇到空格或逗号的时候,直接跳过 2. 当遇到引号的时候,则要得到键,即两个引号之间的内容,存储在key中 3. 当遇到冒号的时候,则要得到键值,但是键值可能是一个字符串也可能会是一个对象,所以接着判断遇到的事冒号还是左括号 4. 当遇到右括号的时候,嵌套回退一层参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;map&lt;string, string&gt; ans,stf; // 存储键值对,以及继承关系(对象的嵌套)string get(int &amp;i, string str) &#123; string s; while(str[i++] &amp;&amp; str[i] != '"') &#123; if(str[i] == '\\') s += str[++i]; else s += str[i]; &#125; return s;&#125; int main() &#123; int n,m; string s,str,name,key,val; // cin&gt;&gt;n&gt;&gt;m; (cin &gt;&gt; n &gt;&gt; m).get(); ////注意读取换行符，否则影响之后的处理 for(int i = 0;i &lt; n; i++) &#123;// cin&gt;&gt;s; getline(cin, s); str += s; &#125; for(int i = 1; i &lt; str.size()-1; i++) &#123; if(str[i] == ' '||str[i] == ',') continue; else if(str[i] == '"') &#123; key = get(i,str); // 获取键 &#125; else if(str[i] == ':') &#123; while(str[++i] == ' ') continue; if(str[i] == '"') &#123; val = get(i,str); ans[name + '.' + key] = val; &#125; else if(str[i] == '&#123;') &#123; ans[name + '.' + key] = "OBJECT"; stf[name + '.' + key] = name; // 保存父亲键名,后面回退会用到 name += ('.' + key); // 更新对象嵌套关系 &#125; &#125; else if(str[i] == '&#125;') name = stf[name]; // 对象完毕,向前回退 &#125; while(m--) &#123; cin&gt;&gt;s; s = '.' + s; if(ans[s] == "") cout&lt;&lt;"NOTEXIST"&lt;&lt;endl; else if (ans[s] == "OBJECT") cout &lt;&lt; ans[s] &lt;&lt; endl; else cout &lt;&lt; "STRING " &lt;&lt; ans[s] &lt;&lt; endl; &#125; return 0;&#125; 4. 通信网络]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue路由基础]]></title>
    <url>%2Fvue%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[vue路由配置 安装 npm install vue-router --save 或者 cnpm install vue-router --save 引入并使用(main.js) 12345import VueRouter from "vue-router"Vue.use(VueRouter) 配置路由 创建组件,引入组件 定义路由 (建议复制) 1234const routes = &#123; '/': Home, '/about': About&#125; 实例化VueRouter 123const router = new VueRouter&#123;( routes //详单与routes: routes)&#125; 挂载 12345new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) 路由的简单用法12345678910111213141516171819202122232425262728293031323334import Vue from 'vue'import App from './App.vue'import VueRouter from 'vue-router'Vue.use(VueRouter);//1.创建组件import Home from "./components/Home.vue";import News from "./components/News.vue";//2. 配置路由const routes = [ &#123; path: '/home', component: Home &#125;, &#123; path: '/news', component: News &#125;, // &#123; path: '*', redirect: '/home' &#125;]//3.实例化VueRouterconst router = new VueRouter(&#123; routes&#125;)//4. 挂载路由new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) 1234567891011//5. &lt; router-view &gt; &lt;/router-view&gt;放在根组件app&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/news&quot;&gt;新闻&lt;/router-link&gt; &lt;hr&gt; &lt;router-view&gt; &lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中的组件传值]]></title>
    <url>%2Fvue%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[Vue中的组件传值父子组件传值首先需要在父组件中引入子组件并注册(挂载) 12345678910111213141516// 引入组件 挂载组件import HelloWorld from "./components/HelloWorld.vue";//挂载组件 components: &#123; "v-home": HelloWorld &#125;//使用子组件&lt;v-home&gt;&lt;/v-home&gt;//如果想要在调用子组件的同时给子组件传值//1. 在使用子组件的时候绑定属性 // &lt;v-home :title = "title"&gt;&lt;/v-home&gt;//2. 在子组件中定义属性接收父组件的传值// props: ["title"]//ps:如果子组件和父组件含有同名的变量,以父组件为主,但尽量不要这样用 12345678910//如果想在子组件调用父组件的方法//比如父组件中有一个run方法// run(data) &#123;// alert("我是父组件的run方法" + data);// &#125;//1. 同样的方法 &lt;v-header :title="title" :run="run"&gt;&lt;/v-header&gt;//2. 子组件接收 props: ["title", "run"]//3. 用Button组件进行测试 &lt;button @click="run(666)"&gt;调用父组件的方法&lt;/button&gt;//:home="this" 可以把整个父组件传过去 非父子组件传值123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.新建一个js文件 然后引入vue 实例化vue 最后暴露这个实例 import Vue from 'vue' var vueEvent = new Vue(); export default vueEvent;// 2.在要广播的地方引入刚才定义的实例 import Bus from '../bus.js';// 3.通过vueEvent.$emit('名称',数据) import Bus from '../bus.js'; export default &#123; name: 'first', data () &#123; return &#123; value: '我来自first.vue组件！' &#125; &#125;, methods:&#123; add()&#123;// 定义add方法，并将msg通过txt传给second组件 Bus.$emit('txt',this.value); &#125; &#125; &#125;// 4.在接收数据的地方通过// vueEvent.$on('名称',function(data) &#123;// &#125;) import Bus from '../bus.js'; export default &#123; name: 'second', data () &#123; return &#123; &#125; &#125;, mounted:function()&#123; Bus.$on('txt',function(val)&#123;//监听first组件的txt事件 console.log(val); &#125;); &#125; &#125; 父组件主动获取子组件数据12345678//1.调用子组件的时候定义一个ref//&lt;v-header ref="header"&gt;&lt;/v-header&gt; &lt;v-home :title="title" :home="this" ref="home"&gt;&lt;/v-home&gt;//2.在父组件this.$refs.header.属性/方法 getChildData() &#123; console.log(this.$refs.home.msg); //子组件属性 this.$refs.home.run("newbg"); //子组件方法 &#125; 子组件主动获取父组件数据的方法1234//this.$parent.数据/方法 getParent() &#123; console.log(this.$parent.title + "------子组件主动获取父组件的数据"); &#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子列和问题]]></title>
    <url>%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最大子列和问题题目给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：与样例等价，测试基本正确性；数据2：102个随机整数；数据3：103个随机整数；数据4：104个随机整数；数据5：105个随机整数； 输入格式:输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。 输出格式:在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例:6-2 11 -4 13 -5 -2输出样例:20 解题思路最先想到的值暴力破解,但是需要三重循环,既要控制序列的首和尾,还要有一层循环进行累加,只能通过一部分测试样例 12345678910111213141516int MaxSubseqSum1 ( int A[], int N ) &#123; int ThisSum, MaxSum = 0; int i, j, k; for ( i = 0; i &lt; N; i++ ) &#123; //i是子列左端位置。 for ( j = i; j &lt; N; j++ ) &#123; //j是子列右端位置。 ThisSum = 0; // 每轮都要把ThisSum归零，累加新一轮的子列和。 for ( k = i; k &lt; j; k++ ) //将A[i]~A[j]累加，得到子列和。 ThisSum += A[k]; if ( ThisSum &gt; MaxSum ) //如果这轮的子列和比最大子列和还大，存入MaxSum. MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; 二重循环也可以实现暴力破解,一方面控制起始端,另一方不断向左累加,更新max的值 12345678910111213141516int MaxSubseqSum2 ( int A[], int N ) &#123; int ThisSum, MaxSum = 0; int i, j; for ( i = 0; i &lt; N; i++ ) &#123; //i是子列左端位置。 ThisSum = 0; //A[i]~A[j]的子列和。 for ( j = i; j &lt; N; j++ ) &#123; //j是子列右端位置。 ThisSum += A[j]; //对于相同的i，不同的j，只要在j-1处再累加1项即可。 if ( ThisSum &gt; MaxSum ) //更新MaxSum. MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; 最优的方法是在线处理,只用一层循环控制起始端不断向右累加,保证向右累加只会使结果变大,总而言之灰常巧妙! 参考代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 100010;int num[N];int main() &#123; int max,k,now; max = now = 0; // 当前求和和最大求和 cin&gt;&gt;k; for(int i = 0;i &lt; k; i++) &#123; cin&gt;&gt;num[i]; &#125; for(int i = 0; i &lt; k; i++) &#123; now += num[i]; if(now &gt; max) max = now; else if(now &lt; 0) now = 0; &#125; cout&lt;&lt;max; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo中Markdown语法使用]]></title>
    <url>%2FHexo%E4%B8%ADMarkdown%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Hexo中Markdown语法(GFM)使用提起Markdown，是项目、是不可多得的助手。Markdown 是一种轻量级的”标记语言”，优点在于（1）可以更加专注文章内容而不是排版样式。（2）轻松的导出 HTML 和本身的 .md 文件。（3）纯文本内容，兼容所有的文本编辑器与字处理软件。（4）可读，直观。适合所有人的写作语言。查资料了解到，Hexo下使用的MarkDown为Github的 GFM ，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准的MarkDown稍有不同，使用过程中需要注意一些，在下面的介绍中我会进行说明的请放心。 1 Markdown语法1.1 标题Markdown支持6种级别的标题，对应html标签 h1 ~ h6 123456# h1 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## h2 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### h3 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### h4 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### h5 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### h6 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt; 1.2 段落及区块引用Markdown提供了一个特殊符号 &gt; 用于段首进行强调，被强调的文字部分将会高亮显示 1&gt; 这段文字将会被高亮显示... 以上标记显示效果如下： 1.3 插入链接或图片Markdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记 12[点击跳转至百度](https://www.baidu.com)![图片](https://raw.githubusercontent.com/wugenqiang/picGo/master/pictures/015.jpg) 以上标记显示效果如下： 点击跳转至百度 图片 注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。 1.4 列表Markdown支持有序列表和无序列表两种形式： 无序列表使用 * 或 + 或 - 标识 有序列表使用数字加 . 标识，例如：1. 1.5 分隔线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- 以上标记显示效果如下： 1.6 内容强调有时候，我们对某一部分文字进行强调，使用 * 或 _ 包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗 12345678*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__***这里是加粗并斜体***___这里是加粗并斜体___ 以上标记显示效果如下： 这里是斜体这里是斜体 这里是加粗这里是加粗 这里是加粗并斜体这里是加粗并斜体 1.7 删除线1这样来 ~~删除一段文本~~ 以上标记显示效果如下： 这样来 删除一段文本 1.8 高亮显示12使用&lt;code&gt;\`&lt;/code&gt;来强调字符//想打出 ` (反引号)需要转义，加&lt;code&gt;&lt;/code&gt;标签强调比如`突出背景色`来显示强调效果 以上标记显示效果如下： 使用来强调字符比如突出背景色 来显示强调效果 1.9 嵌套引用123456789101112131415&gt; 动物&gt;&gt; 水生动物&gt;&gt; 陆生动物&gt;&gt;&gt; 猴子&gt;&gt;&gt; 人&gt;&gt;&gt;&gt; 程序猿&gt;&gt;&gt;&gt; 攻城狮&gt;&gt;产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记&gt;&gt; 两栖类动物&gt;&gt;&gt; 大鳄鱼唐老鸭两个回车结束引用,不在引用范围内了！ 以上标记显示效果如下： 动物 水生动物陆生动物 猴子人 程序猿攻城狮产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记 两栖类动物 大鳄鱼唐老鸭 两个回车结束引用,不在引用范围内了！ 1.10 修改图片1.10.1 设置图片尺寸在 markdown 直接使用提供的语法引入图片是无法设置大小的，所以我们需要用到 html 的 img 标签。 1&lt;img width=&quot; &quot; alt=&quot;描述&quot; src=&quot;url&quot;/&gt; 例如： 1&lt;img width=&quot;267px&quot; alt=&quot;欢迎来访呀朋友&quot; src=&quot;https://raw.githubusercontent.com/wugenqiang/picGo/master/pictures/013.jpg&quot;/&gt; 1.10.2 设置图片居中在 markdown 设置图片居中是需要通过 div 来控制的。 1&lt;div align=center&gt;&lt;img width=&quot;267px&quot; alt=&quot;欢迎来访呀朋友&quot; src=&quot;https://raw.githubusercontent.com/wugenqiang/picGo/master/pictures/013.jpg&quot;/&gt;&lt;/div&gt; 1.11 插入代码块Markdown在IT圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码。方法是，使用三个反引号 ` 进行包裹即可。如果是行内代码引用，使用单个反引号进行包裹 代码块语法遵循标准 markdown 代码，使用 ``` 结束 例如：12 ​1234#!/usr/bin/env python# -*- coding: utf-8 -*-print 'Hello World! ​ 12以上标记显示效果如下： #!/usr/bin/env python print ‘Hello World! 1234注：很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧esc键下面的第一个键点击即可。有人会问：如何在代码块中打出 实际上是使用 4个包含 3个 就可以了，想表示更多，最外层+1就好了。 12​```​``` 1.12 插入表格表格是Markdown语法中比较复杂的一个，其语法如下： 12345列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 以上标记显示效果如下： 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 可以使用冒号来定义对齐方式： 全居中样式： 123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 以上标记显示效果如下： 表头 条目一 条目二 项目 项目一 项目二 可能有人喜欢左对齐或者右对齐，也可以设置: 1234| 左对齐 | 右对齐 | 居中 || :-------- | -------:| :--: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 以上标记显示效果如下： 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 注：三个短竖杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 1.13 特殊符号处理Markdown使用反斜杠\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理： 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：\ \ =&gt; \ 。 注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。 重要：MarkDown表格中使用竖线，如何做？ 表格中使用竖线 竖线数目| 一个竖线: &amp; # 1 2 4 ;|| 两个竖线: &amp; # 1 2 4 ; &amp; # 1 2 4 ; 1.14 文本居中引用123456&#123;% cq %&#125;人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！&#123;% endcq %&#125; 以上标记显示效果如下： 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ 注：如果想修改字号，可以如下面这样设置： 12345678&lt;font size=&quot;4&quot;&gt;&#123;% cq %&#125; 人生乃是一面镜子， 从镜子里认识自己， 我要称之为头等大事， 也只是我们追求的目的！&#123;% endcq %&#125;&lt;/font&gt; 以上标记显示效果如下： 人生乃是一面镜子，从镜子里认识自己，我要称之为头等大事，也只是我们追求的目的！ 1.15 主题自带样式 note 标签1&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; 以上标记显示效果如下： default 1&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt; 以上标记显示效果如下： primary 1&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt; 以上标记显示效果如下： success 1&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt; 以上标记显示效果如下： warning 1&lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; 以上标记显示效果如下： danger 在主题配置文件中需要配置下: 123456789# Note tag (bs-callout).note: # 风格 style: flat # 要不要图标 icons: true # 圆角矩形 border_radius: 3 light_bg_offset: 0 1.16 文字处理1.16.1 文字背景色1234&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FFFF00&gt;背景色的设置是按照十六进制颜色值：#FFFF00&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;背景色的设置是按照十六进制颜色值：#D1EEEE&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#C0FF3E&gt;背景色的设置是按照十六进制颜色值：#C0FF3E&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#54FF9F&gt;背景色的设置是按照十六进制颜色值：#54FF9F&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 背景色的设置是按照十六进制颜色值：#FFFF00 背景色的设置是按照十六进制颜色值：#D1EEEE 背景色的设置是按照十六进制颜色值：#C0FF3E 背景色的设置是按照十六进制颜色值：#54FF9F 1.16.2 文字字体123&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;宋体&quot;&gt;我是宋体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑字&lt;/font&gt; 效果如下： 我是黑体字我是宋体字我是微软雅黑字 1.16.3 文字大小12345size为1：&lt;font size=&quot;1&quot;&gt;size为1&lt;/font&gt;size为2：&lt;font size=&quot;2&quot;&gt;size为2&lt;/font&gt;size为3：&lt;font size=&quot;3&quot;&gt;size为3&lt;/font&gt;size为4：&lt;font size=&quot;4&quot;&gt;size为4&lt;/font&gt;size为10：&lt;font size=&quot;10&quot;&gt;size为10&lt;/font&gt; 效果如下： size为1：size为1size为2：size为2size为3：size为3size为4：size为4size为10：size为10 1.16.4 文字颜色12345678红色文字：&lt;font color=&quot;red&quot;&gt;红色文字&lt;/font&gt;浅红色文字：&lt;font color=&quot;#dd0000&quot;&gt;浅红色文字&lt;/font&gt; 蓝色文字：&lt;font color=&quot;blue&quot;&gt;蓝色文字&lt;/font&gt;浅蓝色文字：&lt;font color=&quot;#0000dd&quot;&gt;浅蓝色文字&lt;/font&gt;绿色文字：&lt;font color=&quot;green&quot;&gt;绿色文字&lt;/font&gt;金黄色文字：&lt;font color=&quot;#FFFF00&quot;&gt;金黄色文字&lt;/font&gt;浅黄色文字：&lt;font color=&quot;#dddd00&quot;&gt;浅黄色文字&lt;/font&gt; 深黄色文字：&lt;font color=&quot;#666600&quot;&gt;深黄色文字&lt;/font&gt; 效果如下： 红色文字：红色文字浅红色文字：浅红色文字蓝色文字：蓝色文字浅蓝色文字：浅蓝色文字绿色文字：绿色文字金黄色文字：金黄色文字浅黄色文字：浅黄色文字深黄色文字：深黄色文字 需要其它更多的颜色，可以到下面这个网址查更多颜色的 RGB，或者直接用颜色的英文代替 RGBRGB颜色查询对照表 1.16.4 同时改变字体，字号和颜色123456789&lt;font face=&quot;字体&quot; size=&quot;字号&quot; color=&quot;颜色&quot;&gt;这里是需要突出显示的内容&lt;/font&gt;&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=red&gt;我是红色&lt;/font&gt;&lt;font color=#008000&gt;我是绿色&lt;/font&gt;&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;&lt;font size=5&gt;我是尺寸&lt;/font&gt;&lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt; 效果如下： 这里是需要突出显示的内容我是黑体字我是微软雅黑我是华文彩云我是红色我是绿色我是蓝色我是尺寸我是黑体，绿色，尺寸为5 1.17 使用Emoji表情使用前首先要开启 emoji，默认是不显示的，参考：开启emoji表情开启 emoji 后进行操作 举例： 1Hello Hexo NexT :smile: 效果： Hello Hexo NexT 😄 更多可用 Emoji 代码参见 emoji-cheat-sheet 和 emojicopy 1.18 复选框列表(github可用,hexo不支持)在列表符号后面加上 [x] 或者 [ ] 代表选中或者未选中情况 123- [ ] content -空格[空格]空格content 解释: [ ]括号里面的空格可以换成[x],代表选中对话框 C C++ Java Qt Android C# .NET 1.19 脚注使用 [^1] [^1]:的脚注对来表示 1234567Here is a footnote reference,[^1] and another.[^longnote][^1]: Here is the footnote.[^longnote]: Here&apos;s one with multiple blocks. Subsequent paragraphs are indented to show that they belong to the previous footnote. 效果如下： Here is a footnote reference,[1] and another.[2] 2 文章编辑2.1 文章配置在hexo文件夹下右键点击Git Bash here后键入$hexo new page &quot;name&quot;，source/_post 文件夹中就会生成name.md文件，打开后即可编辑，编辑格式如下： 123456789---title: 文章名date: 2019-04-09 12:27:52 //发表日期updated: 2019-04-09 13:27:52 //更新日期categories: Markdown //文章分类tags: [tag1,tag2] //文章标签，多标签时使用英文逗号隔开photos: //如果使用Fancybox（文章头部展示图片），如此设置 //注意冒号后面有空格--- 2.2 文章折叠在要显示的文字末尾添加如下代码实现文章在主页的折叠显示。 1&lt;!-- more --&gt;]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
